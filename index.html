<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Daily Specials</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { height:100%; overflow:hidden; }
    body {
      font-family: 'Comic Sans MS', cursive;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      position: relative;
    }
    /* Background with brightness filter support */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('bg/backgd.jpg') center/cover no-repeat;
      z-index: -1;
      filter: brightness(1);
    }
    header {
      background: rgba(0,0,0,0.5);
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      /* Responsive header font: scales with viewport width (5vw) between 1.5rem-4rem */
      /* Larger screens get proportionally larger text; clamp() prevents extremes */
      font-size: clamp(1.5rem, 5vw, 4rem);
      font-weight: bold;
    }
    #clock {
      position: absolute;
      right: 1rem;
      font-size: clamp(1rem, 3vw, 2.5rem);
      font-weight: normal;
    }
    #clock.hidden {
      display: none;
    }
    #specials {
      flex: 1;
      /* Responsive padding: scales with viewport width between 1rem-3rem */
      padding: clamp(1rem, 2vw, 3rem);
      /* Responsive specials text: scales with viewport width (3vw) between 1rem-6rem */
      /* 3vw means 3% of screen width; larger TVs get bigger fonts automatically */
      font-size: clamp(1rem, 3vw, 6rem);
      line-height: 1.1;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
      -webkit-overflow-scrolling: touch;
    }
    /* Fix bullet point spacing and indentation */
    #specials ul {
      margin: 0.5em 0 0.5em 2em;
      padding-left: 0;
    }
    #specials ul li {
      margin-bottom: 0;
      line-height: 1.3;
    }
    #specials ul li p {
      margin: 0;
      display: inline;
    }
    #specials ol {
      margin: 0.5em 0 0.5em 2em;
      padding-left: 0;
    }
    #specials ol li {
      margin-bottom: 0;
      line-height: 1.3;
    }
    #specials ol li p {
      margin: 0;
      display: inline;
    }
    .version {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.7rem;
      opacity: 0.5;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <header>
    <span id="header">Specials</span>
    <span id="clock">00:00</span>
  </header>
  <div id="specials">Loading…</div>
  <div class="version">314Sign v0.9.1 | © 2025 J Stekervetz | CC BY-NC 4.0</div>

  <script>
  const specialsDiv = document.getElementById('specials');
  const headerEl = document.getElementById('header');
  const clockEl = document.getElementById('clock');
  let currentMenu = localStorage.getItem('currentMenu') || 'menus/dinner.txt';
  let lastText = '';
  let lastEtag = null;
  let rulesCheckInterval = null;
  let clockInterval = null;
  let clock24Hour = true; // Default to 24-hour format

  // Update clock display
  function updateClock() {
    const now = new Date();
    let hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    
    if (clock24Hour) {
      clockEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes}`;
    } else {
      // 12-hour format with AM/PM
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12 || 12; // Convert 0 to 12 for midnight
      clockEl.textContent = `${hours}:${minutes} ${ampm}`;
    }
  }

  // Poll interval in milliseconds. Default to 3000ms (3s).
  // This value can be overridden from config.json using one of:
  //  - pollIntervalMs: number (milliseconds)
  //  - pollIntervalSeconds: number (seconds)
  //  - pollInterval: number (seconds)  -- legacy/short key
  let pollIntervalMs = 3000;
  
  // Font scale percentage. Default to 5% of viewport width.
  // Can be overridden via fontScalePercent in config.json.
  let fontScalePercent = 5;

    // Check schedule rules and auto-switch menu if enabled
    function checkScheduleRules() {
      fetch('rules.json?' + Date.now())
        .then(r => r.ok ? r.json() : null)
        .then(data => {
          if (!data || !data.enabled || !data.rules) return;
          
          const now = new Date();
          const currentDay = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][now.getDay()];
          const currentTime = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
          
          // Find matching rule
          for (const rule of data.rules) {
            if (!rule.days.includes(currentDay)) continue;
            
            // Handle time ranges that cross midnight
            const startTime = rule.startTime || '00:00';
            const endTime = rule.endTime || '23:59';
            
            let matches = false;
            if (startTime <= endTime) {
              // Normal range (e.g., 09:00 - 17:00)
              matches = currentTime >= startTime && currentTime < endTime;
            } else {
              // Crosses midnight (e.g., 22:00 - 07:00)
              matches = currentTime >= startTime || currentTime < endTime;
            }
            
            if (matches && rule.menu && rule.menu !== currentMenu) {
              console.log('Auto-switching to', rule.menu, 'based on rule:', rule.name);
              switchMenu(rule.menu);
              break;
            }
          }
        })
        .catch(err => console.warn('Rules check failed:', err));
    }

    // Switch menu
    function switchMenu(filename) {
      currentMenu = filename;
      localStorage.setItem('currentMenu', filename);
      
      // Reset state and poll immediately
      lastText = '';
      lastEtag = null;
      pollSpecials();
    }

    // --------------------------------------------------------------------
    // 1. Load config.json (once)
    // --------------------------------------------------------------------
    fetch('config.json?' + Date.now())
      .then(r => r.ok ? r.json() : {})
      .then(cfg => {
        // Apply background/font from config if present
        if (cfg.bg)   document.body.style.backgroundImage = `url('bg/${cfg.bg}')`;
        if (cfg.font) document.body.style.fontFamily = cfg.font;
        
        // Apply header font separately if set (falls back to body font)
        if (cfg.headerFont) {
          const headerEl = document.querySelector('header');
          if (headerEl) headerEl.style.fontFamily = cfg.headerFont;
        }
        
        // Apply header text if set (default 'Specials')
        if (cfg.headerText) {
          headerEl.textContent = cfg.headerText;
        }
        
        // Show/hide clock based on config (default hidden)
        // Start by hiding it
        clockEl.classList.add('hidden');
        if (clockInterval) {
          clearInterval(clockInterval);
          clockInterval = null;
        }
        
        // Then show if enabled
        if (cfg.showClock) {
          clockEl.classList.remove('hidden');
          // Set clock format (default to 24-hour if not specified)
          clock24Hour = cfg.clock24Hour !== false;
          updateClock();
          clockInterval = setInterval(updateClock, 1000);
        }

        // Configure poll interval from config (supports multiple keys)
        if (cfg && typeof cfg === 'object') {
          // Prefer explicit milliseconds value if provided
          if (Number.isFinite(cfg.pollIntervalMs)) {
            pollIntervalMs = Number(cfg.pollIntervalMs);
          } else if (Number.isFinite(cfg.pollIntervalSeconds)) {
            pollIntervalMs = Number(cfg.pollIntervalSeconds) * 1000;
          } else if (Number.isFinite(cfg.pollInterval)) {
            // legacy shorthand interpreted as seconds
            pollIntervalMs = Number(cfg.pollInterval) * 1000;
          }

          // Validate sensible range; fall back to default on invalid values
          if (!Number.isFinite(pollIntervalMs) || pollIntervalMs <= 0) {
            pollIntervalMs = 3000;
          }
          
          // Load font scale percentage from config if provided
          if (Number.isFinite(cfg.fontScalePercent)) {
            fontScalePercent = Number(cfg.fontScalePercent);
          }
          
          // Apply font scale by updating CSS custom property
          if (fontScalePercent > 0) {
            const specials = document.getElementById('specials');
            if (specials) {
              specials.style.fontSize = 'clamp(1rem, ' + fontScalePercent + 'vw, 6rem)';
            }
          }
          
          // Load and apply header size
          if (Number.isFinite(cfg.headerSizePercent)) {
            const header = document.querySelector('header');
            if (header) {
              header.style.fontSize = 'clamp(1.5rem, ' + cfg.headerSizePercent + 'vw, 8rem)';
            }
          }
          
          // Load and apply background brightness
          if (Number.isFinite(cfg.bgBrightness)) {
            const style = document.createElement('style');
            style.id = 'bg-brightness-style';
            style.textContent = 'body::before { filter: brightness(' + cfg.bgBrightness + ') !important; }';
            const existing = document.getElementById('bg-brightness-style');
            if (existing) existing.remove();
            document.head.appendChild(style);
          }
        }
      })
      .catch(() => console.warn('config.json missing – using defaults'))
      .finally(startPolling);

    // --------------------------------------------------------------------
    // 2. Poll specials.txt – ETag-aware, fallback to text compare
    // --------------------------------------------------------------------
    function startPolling() {
      // Check rules immediately and then every minute
      checkScheduleRules();
      rulesCheckInterval = setInterval(checkScheduleRules, 60000);
      
      // Check config for font scale changes every 10 seconds
      setInterval(checkConfigChanges, 10000);
      
      pollSpecials();
    }
    
    let lastReloadToken = null;
    
    function checkConfigChanges() {
      // Check for reload trigger
      fetch('reload.txt?' + Date.now(), { cache: 'no-store' })
        .then(r => r.ok ? r.text() : '')
        .then(token => {
          if (token && lastReloadToken === null) {
            // First load, just store the token
            lastReloadToken = token.trim();
          } else if (token && token.trim() !== lastReloadToken) {
            // Token changed, reload the page
            location.reload();
          }
        })
        .catch(() => {});
      
      // Check for font scale changes
      fetch('config.json?' + Date.now(), { cache: 'no-store' })
        .then(r => r.ok ? r.json() : {})
        .then(cfg => {
          // Check if font scale changed
          if (Number.isFinite(cfg.fontScalePercent) && cfg.fontScalePercent !== fontScalePercent) {
            fontScalePercent = cfg.fontScalePercent;
            const specials = document.getElementById('specials');
            if (specials) {
              specials.style.fontSize = 'clamp(1rem, ' + fontScalePercent + 'vw, 6rem)';
            }
          }
          
          // Check if header size changed
          if (Number.isFinite(cfg.headerSizePercent)) {
            const header = document.querySelector('header');
            if (header) {
              const currentSize = header.style.fontSize;
              const newSize = 'clamp(1.5rem, ' + cfg.headerSizePercent + 'vw, 8rem)';
              if (currentSize !== newSize) {
                header.style.fontSize = newSize;
              }
            }
          }
          
          // Check if background brightness changed
          if (Number.isFinite(cfg.bgBrightness)) {
            const style = document.createElement('style');
            style.id = 'bg-brightness-style';
            style.textContent = 'body::before { filter: brightness(' + cfg.bgBrightness + ') !important; }';
            const existing = document.getElementById('bg-brightness-style');
            if (existing) existing.remove();
            document.head.appendChild(style);
          }
        })
        .catch(() => {});
    }

    function pollSpecials() {
      fetch(currentMenu + '?' + Date.now(), {
        cache: 'no-store',
        headers: { 'Cache-Control': 'no-cache' }
      })
        .then(r => {
          if (!r.ok) throw new Error('HTTP ' + r.status);

          const etag = r.headers.get('ETag');
          const hasEtag = etag && etag !== lastEtag;

          // If ETag changed → file changed → read text
          if (hasEtag) {
            lastEtag = etag;
            return r.text();
          }

          // No ETag or same ETag → read text anyway (safe fallback)
          return r.text().then(text => {
            if (text === lastText) {
              // No change → skip DOM update
              return null;
            }
            return text;
          });
        })
        .then(newText => {
          if (newText !== null && newText !== undefined) {
            lastText = newText;
            // Parse Markdown and render as HTML
            let trimmed = newText.trim() || 'No specials today.';
            
            // Check for embedded font scale at the top of the file [FONTSCALE:X]
            const fontScaleMatch = trimmed.match(/^\[FONTSCALE:(\d+(?:\.\d+)?)\]\n?/i);
            if (fontScaleMatch) {
              const menuFontScale = parseFloat(fontScaleMatch[1]);
              // Remove the fontscale directive from display
              trimmed = trimmed.replace(/^\[FONTSCALE:\d+(?:\.\d+)?\]\n?/i, '');
              // Apply font scale to specials div
              const specials = document.getElementById('specials');
              if (specials && menuFontScale > 0 && menuFontScale <= 20) {
                specials.style.fontSize = 'clamp(1rem, ' + menuFontScale + 'vw, 6rem)';
              }
            }
            
            // Process color tags line by line to prevent bleeding
            const lines = trimmed.split('\n');
            const processedLines = lines.map(line => {
              let processed = line;
              // Apply color tags within this line only
              const colorMap = {
                r: '#ff4444', y: '#ffdd44', g: '#44ff44', b: '#4488ff',
                o: '#ff8844', p: '#ff44ff', w: '#ffffff'
              };
              
              Object.keys(colorMap).forEach(colorKey => {
                const color = colorMap[colorKey];
                // Replace {color} with opening span, text continues to end of line
                const regex = new RegExp('\\{' + colorKey + '\\}(.*)$', 'i');
                processed = processed.replace(regex, '<span style="color:' + color + '">$1</span>');
              });
              
              return processed;
            });
            
            let processedText = processedLines.join('\n');
            
            // Check for font size override tags [sX]...[/s] where X is percentage
            const sizeRegex = /\[s(\d+(?:\.\d+)?)\]([\s\S]*?)\[\/s\]/gi;
            processedText = processedText.replace(sizeRegex, (match, percent, content) => {
              return `<span style="font-size: ${percent}vw">${content}</span>`;
            });
            
            // Check for alignment tags [center]...[/center] and [right]...[/right]
            processedText = processedText.replace(/\[center\]([\s\S]*?)\[\/center\]/gi, '<div style="text-align: center">$1</div>');
            processedText = processedText.replace(/\[right\]([\s\S]*?)\[\/right\]/gi, '<div style="text-align: right">$1</div>');
            
            // Convert custom bullet syntax after color processing
            const withBullets = processedText.replace(/^- /gm, '• ');
            let html = marked.parse(withBullets);
            
            specialsDiv.innerHTML = html;
          }
        })
        .catch(err => {
          console.error('Specials load failed:', err);
          specialsDiv.textContent = 'Error loading specials – retrying…';
        })
        .finally(() => {
          // Use configured poll interval (ms). This keeps a single timeout
          // chain to avoid overlapping polls.
          setTimeout(pollSpecials, pollIntervalMs);
        });
    }

    // --------------------------------------------------------------------
    // 3. Full reload every 5 minutes (catches config/background changes)
    // --------------------------------------------------------------------
    setInterval(() => location.reload(), 5 * 60 * 1000);
  </script>
</body>
</html>